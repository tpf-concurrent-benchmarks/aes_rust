use super::*;

#[test]
fn test_rot_word() {
    let word: Word = 0x09cf4f3c;
    let expected_word: Word = 0xcf4f3c09;
    assert_eq!(AESCipher::rot_word(word), expected_word);
}

#[test]
fn test_sub_word() {
    let word: Word = 0xcf4f3c09;
    let expected_word: Word = 0x8a84eb01;
    assert_eq!(AESCipher::sub_word(word), expected_word);
}

#[test]
fn test_shift_rows() {
    let mut state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0xbf, 0xb4, 0x41, 0x27],
        [0x5d, 0x52, 0x11, 0x98],
        [0x30, 0xae, 0xf1, 0xe5]
    ]);

    let expected_state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0xb4, 0x41, 0x27, 0xbf],
        [0x11, 0x98, 0x5d, 0x52],
        [0xe5, 0x30, 0xae, 0xf1]
    ]);

    state.shift_rows();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}

#[test]
fn test_inv_shift_rows() {
    let mut state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0xb4, 0x41, 0x27, 0xbf],
        [0x11, 0x98, 0x5d, 0x52],
        [0xe5, 0x30, 0xae, 0xf1]
    ]);

    let expected_state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0xbf, 0xb4, 0x41, 0x27],
        [0x5d, 0x52, 0x11, 0x98],
        [0x30, 0xae, 0xf1, 0xe5]
    ]);

    state.inv_shift_rows();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}

#[test]
fn test_sub_bytes() {
    let mut state = State::new_from_data([
        [0x19, 0xa0, 0x9a, 0xe9],
        [0x3d, 0xf4, 0xc6, 0xf8],
        [0xe3, 0xe2, 0x8d, 0x48],
        [0xbe, 0x2b, 0x2a, 0x08]
    ]);

    let expected_state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0x27, 0xbf, 0xb4, 0x41],
        [0x11, 0x98, 0x5d, 0x52],
        [0xae, 0xf1, 0xe5, 0x30]
    ]);

    state.sub_bytes();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}

#[test]
fn test_inv_sub_bytes() {
    let mut state = State::new_from_data([
        [0xd4, 0xe0, 0xb8, 0x1e],
        [0x27, 0xbf, 0xb4, 0x41],
        [0x11, 0x98, 0x5d, 0x52],
        [0xae, 0xf1, 0xe5, 0x30]
    ]);

    let expected_state = State::new_from_data([
        [0x19, 0xa0, 0x9a, 0xe9],
        [0x3d, 0xf4, 0xc6, 0xf8],
        [0xe3, 0xe2, 0x8d, 0x48],
        [0xbe, 0x2b, 0x2a, 0x08]
    ]);

    state.inv_sub_bytes();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}


#[test]
fn test_get_state_from_data_in() {
    let data_in: [u8; 4 * N_B] = [
        0x32, 0x88, 0x31, 0xe0,
        0x43, 0x5a, 0x31, 0x37,
        0xf6, 0x30, 0x98, 0x07,
        0xa8, 0x8d, 0xa2, 0x34];

    let expected_state = State::new_from_data([
        [0x32, 0x43, 0xf6, 0xa8],
        [0x88, 0x5a, 0x30, 0x8d],
        [0x31, 0x31, 0x98, 0xa2],
        [0xe0, 0x37, 0x07, 0x34]
    ]);

    let state = State::new_from_data_in(data_in);


    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}

#[test]
fn test_set_data_out_from_state() {
    let mut data_out: [u8; 4 * N_B] = [0; 4 * N_B];

    let state = State::new_from_data([
        [0x39, 0x02, 0xdc, 0x19],
        [0x25, 0xdc, 0x11, 0x6a],
        [0x84, 0x09, 0x85, 0x0b],
        [0x1d, 0xfb, 0x97, 0x32]
    ]);

    let expected_data_out: [u8; 4 * N_B] = [
        0x39, 0x25, 0x84, 0x1d,
        0x02, 0xdc, 0x09, 0xfb,
        0xdc, 0x11, 0x85, 0x97,
        0x19, 0x6a, 0x0b, 0x32];

    state.set_data_out(&mut data_out);

    for i in 0..(N_B * 4) {
        assert_eq!(data_out[i], expected_data_out[i]);
    }
}


#[test]
fn test_key_expansion_aes_128() {
    let cipher_key: [u8; 4 * N_K as usize] = [
        0x2b, 0x7e, 0x15, 0x16,
        0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88,
        0x09, 0xcf, 0x4f, 0x3c];

    let expected_words: [Word; N_B * (N_R + 1)] = [
        0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c,
        0xa0fafe17, 0x88542cb1, 0x23a33939, 0x2a6c7605,
        0xf2c295f2, 0x7a96b943, 0x5935807a, 0x7359f67f,
        0x3d80477d, 0x4716fe3e, 0x1e237e44, 0x6d7a883b,
        0xef44a541, 0xa8525b7f, 0xb671253b, 0xdb0bad00,
        0xd4d1c6f8, 0x7c839d87, 0xcaf2b8bc, 0x11f915bc,
        0x6d88a37a, 0x110b3efd, 0xdbf98641, 0xca0093fd,
        0x4e54f70e, 0x5f5fc9f3, 0x84a64fb2, 0x4ea6dc4f,
        0xead27321, 0xb58dbad2, 0x312bf560, 0x7f8d292f,
        0xac7766f3, 0x19fadc21, 0x28d12941, 0x575c006e,
        0xd014f9a8, 0xc9ee2589, 0xe13f0cc8, 0xb6630ca6];

    let mut w: [Word; N_B * (N_R + 1)] = [0; (N_B * (N_R + 1))];

    AESCipher::expand_key(cipher_key, &mut w);

    for i in 0..(N_B * (N_R + 1)) {
        assert_eq!(w[i], expected_words[i]);
    }
}

#[test]
fn test_mix_columns() {
    let mut state = State::new_from_data([
        [0xdb, 0xf2, 0x01, 0xc6],
        [0x13, 0x0a, 0x01, 0xc6],
        [0x53, 0x22, 0x01, 0xc6],
        [0x45, 0x5c, 0x01, 0xc6]
    ]);

    let expected_state = State::new_from_data([
        [0x8e, 0x9f, 0x01, 0xc6],
        [0x4d, 0xdc, 0x01, 0xc6],
        [0xa1, 0x58, 0x01, 0xc6],
        [0xbc, 0x9d, 0x01, 0xc6]
    ]);

    state.mix_columns();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}

#[test]
fn test_cipher() {
    let plain_bytes: [u8; 4 * N_B] = [
        0x32, 0x43, 0xf6, 0xa8,
        0x88, 0x5a, 0x30, 0x8d,
        0x31, 0x31, 0x98, 0xa2,
        0xe0, 0x37, 0x07, 0x34];


    let cipher_key: [u8; 4 * N_K as usize] = [
        0x2b, 0x7e, 0x15, 0x16,
        0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88,
        0x09, 0xcf, 0x4f, 0x3c];

    let expected_cipher_bytes: [u8; 4 * N_B] = [
        0x39, 0x25, 0x84, 0x1d,
        0x02, 0xdc, 0x09, 0xfb,
        0xdc, 0x11, 0x85, 0x97,
        0x19, 0x6a, 0x0b, 0x32];

    let cipher = AESCipher::new(cipher_key);

    let cipher_bytes = cipher.cipher_block(plain_bytes);

    for i in 0..(N_B * 4) {
        assert_eq!(cipher_bytes[i], expected_cipher_bytes[i]);
    }
}


#[test]
fn test_cipher_using_new_u128() {
    let plain_bytes: [u8; 4 * N_B] = [
        0x32, 0x43, 0xf6, 0xa8,
        0x88, 0x5a, 0x30, 0x8d,
        0x31, 0x31, 0x98, 0xa2,
        0xe0, 0x37, 0x07, 0x34];


    let cipher_key: u128 = 0x2b7e151628aed2a6abf7158809cf4f3c;

    let expected_cipher_bytes: [u8; 4 * N_B] = [
        0x39, 0x25, 0x84, 0x1d,
        0x02, 0xdc, 0x09, 0xfb,
        0xdc, 0x11, 0x85, 0x97,
        0x19, 0x6a, 0x0b, 0x32];

    let cipher = AESCipher::new_u128(cipher_key);

    let block = cipher.cipher_block(plain_bytes);

    for i in 0..(N_B * 4) {
        assert_eq!(block[i], expected_cipher_bytes[i]);
    }
}

#[test]
fn test_inv_mix_columns() {
    let mut state = State::new_from_data([
        [0x8e, 0x9f, 0x01, 0xc6],
        [0x4d, 0xdc, 0x01, 0xc6],
        [0xa1, 0x58, 0x01, 0xc6],
        [0xbc, 0x9d, 0x01, 0xc6]
    ]);

    let expected_state = State::new_from_data([
        [0xdb, 0xf2, 0x01, 0xc6],
        [0x13, 0x0a, 0x01, 0xc6],
        [0x53, 0x22, 0x01, 0xc6],
        [0x45, 0x5c, 0x01, 0xc6]
    ]);

    state.inv_mix_columns();

    for i in 0..4 {
        assert_eq!(state.data.get_row(i), expected_state.data.get_row(i));
    }
}


#[test]
fn test_inv_cipher() {
    let expected_plain_text: [u8; 4 * N_B] = [
        0x32, 0x43, 0xf6, 0xa8,
        0x88, 0x5a, 0x30, 0x8d,
        0x31, 0x31, 0x98, 0xa2,
        0xe0, 0x37, 0x07, 0x34];

    let cipher_key: [u8; 4 * N_K as usize] = [
        0x2b, 0x7e, 0x15, 0x16,
        0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88,
        0x09, 0xcf, 0x4f, 0x3c];

    let cipher_bytes: [u8; 4 * N_B] = [
        0x39, 0x25, 0x84, 0x1d,
        0x02, 0xdc, 0x09, 0xfb,
        0xdc, 0x11, 0x85, 0x97,
        0x19, 0x6a, 0x0b, 0x32];

    let cipher = AESCipher::new(cipher_key);

    let plain_text = cipher.inv_cipher_block(cipher_bytes);

    for i in 0..(N_B * 4) {
        assert_eq!(plain_text[i], expected_plain_text[i]);
    }
}
